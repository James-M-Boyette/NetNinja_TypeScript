// Note: the below notes wont make sense in the compiled app.js ...
import { ModernInvoice } from "./classes/invoice.js";
import { ListTemplate } from "./classes/listTemplate.js";
import { Payment } from "./classes/payment.js";
import { HasFormatter } from "./interfaces/HasFormatter.js";

const invoiceOne = new ModernInvoice("BitDegree", "Cirriculum Design", 1500);
const invoiceTwo = new ModernInvoice("BitDegree", "Final Project Design", 2000);

let invoices: ModernInvoice[] = []; // Setting 'invoices' type to this only allows things generated by the Invoice constructor to be stored

invoices.push(invoiceOne);
invoices.push(invoiceTwo);

// *** Interfaces:
// Allows you to enforce structure on a class or object: you can describe what properties, methods, types of methods, types of properties etc can be used
// Note: interfaces are not classes or objects - they don't produce anything.

interface IsPerson {
	name: string;
	age: number;
	speak(a: string): void;
	spend(a: number): number;
}

// The above interface simply spells-out what any variable in the future must have and do if it is declared as an instance of IsPerson:

const me: IsPerson = {
	name: "James",
	age: 37,
	speak(text: string): void {
		// Note that here, what's returned (void) is explicitly stated by us
		console.log(text);
	},
	spend(amount: number) {
		// Note that here, what's returned (number) is inferred by TS
		console.log(`I spend ${amount}`);
		return amount;
	},
};

let someone: IsPerson; // Here, we declare that, in the future, when someone is initialized, it must abide by the 'IsPerson' Interface

const greetPerson = (person: IsPerson) => {
	console.log("Hello", person.name, "!");
}; // Here, we declare a function that can only take an 'IsPerson' object in as its parameter

greetPerson(me); // Here, we pass in our 'me' object ... which has been declared as an 'IsPerson' object

//
// *** Modularized Interfaces (importing & exporting)
//

// Here, we
// 1) declare two variables with our 'HasFormatter' type,
// 2) use our imported "ModernInvoice" class (from invoice.ts) to construct two instances,
// 3) store them in an array that has been defined to accept only 'HasFormatter'-typed objects (which docOne & docTwo are)

let docOne: HasFormatter;
let docTwo: HasFormatter;

docOne = new ModernInvoice("James", "Content Development", 1200);
docTwo = new ModernInvoice("BitDegree", "Sprint 20", 2500);

let docs: HasFormatter[] = [];
docs.push(docOne);
docs.push(docTwo);

// console.log("docs:", docs);

// Putting this all together ...
// HTML form parent
const form = document.querySelector(".new-item-form") as HTMLFormElement;
// console.log(form.children);

// Form Inputs
const type = document.querySelector("#type") as HTMLSelectElement;
const tofrom = document.querySelector("#tofrom") as HTMLInputElement;
const details = document.querySelector("#details") as HTMLInputElement;
const amount = document.querySelector("#amount") as HTMLInputElement;
console.log(amount.value);

// list template instance
const ul = document.querySelector("ul")!;
const list = new ListTemplate(ul);

// Button listener
form.addEventListener("submit", (e: Event) => {
	e.preventDefault();

	let doc: HasFormatter;

	if (type.value === "invoice") {
		doc = new ModernInvoice(
			tofrom.value,
			details.value,
			amount.valueAsNumber
		);
	} else {
		doc = new Payment(tofrom.value, details.value, amount.valueAsNumber);
	}

	list.render(doc, type.value, "end");
});

// *** Generics ***
// const addUID = (obj: object) => { // Problem #1
// const addUID = <T>(obj: T) => { // Problem #2
const addUID = <T extends object>(obj: T) => {
	let uid = Math.floor(Math.random() * 100);
	return { ...obj, uid };
};

let docThree = addUID({ name: "Jessica", age: 36 });

console.log(docThree);
console.log(docThree.name); // .name will throw a TS error on its own ... because
// 1. TS doesn't know what properties were passed *into* addUID (without additional instructions), and therefore doesn't know whether a 'name' or 'age' property do, for certain, exist. In order to capture said type info, we need to use <T> and T ... but this creates a problem
// 2. Now we're not specifying a type - only telling TS to remember *whatever* is passed in. In order to make TS opinionated about this function again we need to also stipulate that whatever is passed in *extend* the type we're expecting - in this case, an object
// Note: you can get very specific, here - isntead of '<T extends object>' you could say '<T extends {name; string}>', requiring an object with 1) a 'name' property that's 2) storing a string

// *** Generics with Interfaces:

// If we create an interface that we want to have *some* flexibility - say have it be able to accept different kinds of data (in object form, string form etc), we can pass in the type using Generic syntax:
interface Resource<T> {
	uid: number;
	resourceName: string;
	data: T;
}
// Now, so long as we also declare the type (here, we're saying that our data is an object with <object>), it can be passed in
const docFour: Resource<object> = {
	uid: 1,
	resourceName: "full name",
	data: { fName: "Luke", lName: "Skywalker" },
};

const docFive: Resource<string[]> = {
	uid: 2,
	resourceName: "shoppingList",
	data: ["apples", "milk", "cleaning supplies"],
};

console.log(docFour, docFive);

// *** Enums
//
// If you want to associate numbers to categories etc in a way that's more manageable - say IDs for set elements of media - you can use enums. Here, we have five types of media ... and instead of having to remember that 'film' is our third ResourceType, we can simply refer to it in our variable as ResourceType.FILM ... Note that what's actually stored is the number/index place
enum ResourceType {
	BOOK,
	SONG,
	FILM,
	AUDIOPLAY,
	PAINTING,
}

interface FilmResource<T> {
	uid: number;
	resourceType: ResourceType;
	data: T;
}

const docSeven: FilmResource<object> = {
	uid: 1,
	resourceType: ResourceType.PAINTING,
	data: { painter: "Money", work: "Water Lillies" },
};

const docEight: FilmResource<string[]> = {
	uid: 12,
	resourceType: ResourceType.FILM,
	data: ["Star Wars"],
};

console.log(docSeven, docEight);
