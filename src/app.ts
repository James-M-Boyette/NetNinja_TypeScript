// Note: the below notes wont make sense in the compiled app.js ...
import { ModernInvoice } from "./classes/invoice.js";
import { ListTemplate } from "./classes/listTemplate.js";
import { Payment } from "./classes/payment.js";
import { HasFormatter } from "./interfaces/HasFormatter.js";

const invoiceOne = new ModernInvoice("BitDegree", "Cirriculum Design", 1500);
const invoiceTwo = new ModernInvoice("BitDegree", "Final Project Design", 2000);

let invoices: ModernInvoice[] = []; // Setting 'invoices' type to this only allows things generated by the Invoice constructor to be stored

invoices.push(invoiceOne);
invoices.push(invoiceTwo);

// *** Interfaces:
// Allows you to enforce structure on a class or object: you can describe what properties, methods, types of methods, types of properties etc can be used
// Note: interfaces are not classes or objects - they don't produce anything.

interface IsPerson {
	name: string;
	age: number;
	speak(a: string): void;
	spend(a: number): number;
}

// The above interface simply spells-out what any variable in the future must have and do if it is declared as an instance of IsPerson:

const me: IsPerson = {
	name: "James",
	age: 37,
	speak(text: string): void {
		// Note that here, what's returned (void) is explicitly stated by us
		console.log(text);
	},
	spend(amount: number) {
		// Note that here, what's returned (number) is inferred by TS
		console.log(`I spend ${amount}`);
		return amount;
	},
};

let someone: IsPerson; // Here, we declare that, in the future, when someone is initialized, it must abide by the 'IsPerson' Interface

const greetPerson = (person: IsPerson) => {
	console.log("Hello", person.name, "!");
}; // Here, we declare a function that can only take an 'IsPerson' object in as its parameter

greetPerson(me); // Here, we pass in our 'me' object ... which has been declared as an 'IsPerson' object

//
// *** Modularized Interfaces (importing & exporting)
//

// Here, we
// 1) declare two variables with our 'HasFormatter' type,
// 2) use our imported "ModernInvoice" class (from invoice.ts) to construct two instances,
// 3) store them in an array that has been defined to accept only 'HasFormatter'-typed objects (which docOne & docTwo are)

let docOne: HasFormatter;
let docTwo: HasFormatter;

docOne = new ModernInvoice("James", "Content Development", 1200);
docTwo = new ModernInvoice("BitDegree", "Sprint 20", 2500);

let docs: HasFormatter[] = [];
docs.push(docOne);
docs.push(docTwo);

// console.log("docs:", docs);

// Putting this all together ...
// HTML form parent
const form = document.querySelector(".new-item-form") as HTMLFormElement;
// console.log(form.children);

// Form Inputs
const type = document.querySelector("#type") as HTMLSelectElement;
const tofrom = document.querySelector("#tofrom") as HTMLInputElement;
const details = document.querySelector("#details") as HTMLInputElement;
const amount = document.querySelector("#amount") as HTMLInputElement;
console.log(amount.value);

// list template instance
const ul = document.querySelector("ul")!;
const list = new ListTemplate(ul);

// Button listener
form.addEventListener("submit", (e: Event) => {
	e.preventDefault();

	let doc: HasFormatter;

	if (type.value === "invoice") {
		doc = new ModernInvoice(
			tofrom.value,
			details.value,
			amount.valueAsNumber
		);
	} else {
		doc = new Payment(tofrom.value, details.value, amount.valueAsNumber);
	}

	list.render(doc, type.value, "end");
});
