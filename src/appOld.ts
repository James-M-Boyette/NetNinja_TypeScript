class Invoice {
	// By default, class properties are public, and can be changed, accessed etc by anyone (you could, after invoiceOne's initialization, change the amount to 1600). If you want to stop people from changing said properties, post-initialization, then use 'private':

	// private client: string; // This will throw an error in our for loop's log command ... bc it's *outside* the class (inside the class, our 'constructor' can interact with 'client' property just fine)
	client: string;
	public details: string; // explicit 'public' declaration of default behavior
	// amount: number; // implicit 'public'
	readonly amount: number; // Readable, but not editable - *both* inside & outside the class (you can't edit in either case)

	// The above will throw errors in TS when left alone bc they're not initialized. When you use a construtor, this fixes the problem:
	constructor(c: string, d: string, a: number) {
		this.client = c;
		this.details = d;
		this.amount = a;
	}

	// Bespoke method
	format() {
		return `${this.client} owes $${this.amount} for ${this.details}`;
	}
}

const invoiceOne = new Invoice("BitDegree", "Cirriculum Design", 1500);
const invoiceTwo = new Invoice("BitDegree", "Final Project Design", 2000);

let invoices: Invoice[] = []; // Setting 'invoices' type to this only allows things generated by the Invoice constructor to be stored

invoices.push(invoiceOne);
invoices.push(invoiceTwo);

// console.log("invoices", invoices);
invoices.forEach((inv) => {
	console.log(inv.client, inv.details, inv.amount, inv.format());
});

const form = document.querySelector(".new-item-form") as HTMLFormElement;
console.log(form.children);

const type = document.querySelector("#type") as HTMLSelectElement;
const tofrom = document.querySelector("#tofrom") as HTMLInputElement;
const details = document.querySelector("#details") as HTMLInputElement;
const amount = document.querySelector("#amount") as HTMLInputElement;
console.log(amount.value);

form.addEventListener("submit", (e: Event) => {
	e.preventDefault();

	console.log(type.value, tofrom.value, details.value, amount.valueAsNumber);
});

// V.2, where we decalre everything within the constructor
class ModernInvoice {
	constructor(
		readonly client: string,
		private details: string,
		public amount: string
	) {}

	format() {
		return `${this.client} owes $${this.amount} for ${this.details}`;
	}
}
